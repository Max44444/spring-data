Задание
=======

В этом задании необходимо научиться связывать сущности с таблицами в базе данных, а также строить запросы на чтение/изменение данных. Шаблон приложение можно найти по ссылке на [github](https://github.com/definetux/spring-data-hw).

Основные требования
-------------------

*   Дополните все сущности необходимыми аннотациями согласно схеме (`shema.drawio`)
*   Дополните сущности аннотациями из Project Lombok
*   Расширьте сервисы, построив 15 запросов (9 - на выборку данных, 6 - на модификацию)
*   Если в запросе нет взаимодействия с несколькими таблицами, постарайтесь ограничиться построением запроса без аннотации @Query (используя подход Query from method name)
*   Если запрос нельзя построить используя `JPQL`, попробуйте реализовать его с помощью [nativeQuery](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query)
*   Прибегайте к использованию нескольких запросов на один use case в крайних случаях
*   Добейтесь того, чтобы приложение запускалось без ошибок и все тесты стали зелеными

Настройка
---------

Для того, чтобы приложение и тесты успешно запустились вам необходимо:

*   скачать и установить [PostgreS](https://www.postgresql.org/)
*   скачать и установить [PgAdmin](https://www.pgadmin.org/) (так же можно пользоваться расширением Postgre SQL Explorer к VS Code)
*   создать две базы данных: `spring-data` и `spring-data-test`
*   скачать и установить плагин [Lombok](https://projectlombok.org/setup/intellij)

Важно!
------

> *   Для успешного выполнения задания вы можете опираться на список интеграционных тестов. Однако при оценивании работы мы так же будем учитывать и качество самих запросов.
> *   В шаблоне вы найдете несколько подсказок по реализации методов.
> *   Большинство операций можно реализовать разными способами. Выбирайте тот, который является наиболее эффективным (меньше обращений к базе данных, меньше кода).
> *   Менять логику тестов нельзя. Добавлять можно абсолютно любой код, до тех пор, пока он соответствует контракту тестов.

Описание запросов
-----------------

*   Поиск пользователей по фамилии

    > описать поиск (операция like) по фамилии, добавить паджинацию, сортировку по фамилии по возрастанию. Запрос должен быть регистронезависимым

*   Поиск пользователей по городу

    > описать поиск по городу используя таблицу offices. Сортировать пользователей по фамилии по возрастанию

*   Поиск самых развивающихся проектов по технологии

    > описать поиск первых 5 проектов, которые используют технологию. Сортировать пользователей по количеству человек на проекте

*   Поиск опытных пользователей

    > описать поиск пользователей, у которых опыт >= указанного. Сортировать пользователей по опыту по убыванию

*   Поиск пользователей по расположению

    > описать поиск по комнате и городу используя таблицы teams и offices. Сортировать пользователей по фамилии по возрастанию

*   Поиск самого крупного проекта

    > описать поиск проекта, в котором больше всего команд. Если команд одинаковое количество, то выбрать проект, в котором больше всего разработчиков. Если разработчиков тоже одинаковое количество, то сортировать проекты по имени по убыванию и взять первый

*   Выборка общей информации по проектам

    > выбрать следующие данные о проекте: название, количество команд, количество разработчиков, список технологий (через запятую). Сортировать данные по имени проекта по возрастанию. Т.к. превратить значения технологий в список, разделенный запятыми, довольно сложно стандартными средствами `JPQL`, можно использовать `nativeQuery` и проекцию данных на интерфейс `ProjectSummaryDto`. Если построить запрос таким образом не получится, то можно использовать любой другой способ, который соответствует тестам.

*   Количество проектов с ролью

    > описать подсчет проектов, в которых есть разработчики, которые занимают определенную роль

*   Поиск офисов, которые занимаются технологией

    > описать поиск офисов, в которых есть проекты, которые используют определенную технологию.

*   Создание нового проект

    > описать логику создания проекта, технологии и команды для проекта. Можно использовать стандартные методы `JpaRepository`

*   Обновление существующей команды

    > описать логику обновления технологии у команды, в которой участников < определенного количества. Можно использовать несколько запросов

*   Обновление существующего офиса

    > описать логику обновления адреса у офиса, если разработчики этого офиса участвуют в проекте

*   Обновление существующей команды

    > описать один запрос, который будет добавлять к имени указанной команды название проекта и название технологии (`Team_Project_Technology`). Необходимо использовать `nativeQuery`

*   Удаление пользователей

    > описать один запрос, который будет удалять пользователей, у которых опыт < указанного количества лет

*   Удаление ролей

    > описать один запрос, который будет удалять все роли по имени, если они не привязаны к пользователям